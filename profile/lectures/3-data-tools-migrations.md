## Миграции

Для корректной работы с базами данных необходимо обеспечить соответствие её схемы коду вашего приложения. Для реализации
этого существует механизм миграций. Миграции это набор SQL скриптов, необходимых к выполнению на базе данных для
формирования корректной схемы. Фактически миграции представляют собой исторические изменения схемы базы данных, ведь как
только миграция доходит до какой-либо среды развертывания, её нельзя изменять, все последующие инкрементальные изменения
должны быть реализованы через новые миграции.

Миграции должны являться частью вашего приложения, должны храниться в системе контроля версий. Существует много
различных механизмов реализации миграций, сегодня мы с вами рассмотрим наиболее популярную библиотеку для решения этих
задач – FluentMigrator.

### Определение миграций

В рамках данной библиотеки одна миграция представляется классом, наследующимся от класса `Migration`. Любая миграция
состоит из двух скриптов, один – для накатывания миграции, другой – для её откатывания. Соответственно, выполнение
второго скрипта возвращает схему базы данных в то состояние, в котором она находилась до выполнения первого.

```csharp
public class InitialMigration : Migration
{
    public override void Up() { }

    public override void Down() { }
}
```

Основной функционал библиотеки FluentMigrator заключается в специальной объектной модели для определения миграций, не
подразумевающей использование SQL кода напрямую. С одной стороны такой подход имеет преимущество того, что миграции
становятся относительно универсальными, позволяя накатить их на различные базы данных. Библиотека предоставляет
провайдеры, транслирующие эти вызовы в нужный SQL код. Но у такого подхода есть недостатки, во-первых – лишний слой
абстракции при работе с базами данных. При разработке микросервисов ситуация перехода на совершенно другую базу данных
это что-то крайне редкое, обычно вы работаете с конкретной базой и знаете об этом. Также, несмотря на то, что библиотека
предоставляет обширное количество абстракций, ими не всегда можно выразить то, какую схему вам необходимо создать.
Библиотека конечно предоставляет возможность использовать SQL напрямую, но комбинация таких способов выглядит как
странная, протёкшая абстракция. Также, предпочитаемый библиотекой синтаксис может не всегда совпадать с принятыми в
вашей команде конвенциями. Например, код в миграции на слайде моё IDE автоформатирует по-другому, перенося все вызовы на
отдельные строки. Читать такое может быть трудно, а менять настройки форматирования всего проекта под один кейс –
довольно странно.

```csharp
public class InitialMigration : Migration
{
    public override void Up()
    {
        Create.Table("users")
            .WithColumn("user_id").AsInt64().PrimaryKey().Identity()
            .WithColumn("user_name").AsString().NotNullable();
    }

    public override void Down()
    {
        Delete.Table("users");
    }
}
```

Что же тогда делать в этой ситуации? Тут стоит отбросить эту объектную модель и использовать библиотеку просто как
движок для накатки миграций, реализуя эти миграции напрямую через SQL скрипты. Для этого, нам нужно будет реализовать
интерфейс `IMigration` вместо наследования от класса `Migration`. В реализации методов этого интерфейса, нам нужно будет
добавить SQL выражения в контекст миграции.

```csharp
public class InitialMigration : IMigration
{
    public void GetUpExpressions(IMigrationContext context)
    {
        context.Expressions.Add(new ExecuteSqlStatementExpression
        {
            SqlStatement = """
            create table users
            (
                user_id bigint primary key generated always as identity,
                user_name text not null 
            );
            """,
        });
    }

    public void GetDownExpressions(IMigrationContext context)
    {
        context.Expressions.Add(new ExecuteSqlStatementExpression
        {
            SqlStatement = """
            drop table users;
            """,
        });
    }

    public string ConnectionString => throw new NotSupportedException();
}
```

Как вы можете заметить, в таком коде довольно много бойлерплейта, для того чтобы от него избавиться, вы можете добавить
свой базовый класс для миграций, требующий лишь задания строк с SQL запросом. Реализовав миграции через SQL скрипты мы
явно используем возможности базы данных. Это позволяет нам описывать таблицы так, как мы будем использовать их в
последующих SQL запросах репозиториев. Также, такой подход позволит упростить процесс перехода на другие инструменты
миграции, если это понадобится в будущем.

Мы научились описывать миграции и совсем скоро посмотрим как их разворачивать. Но, нашим миграциям не хватает ключевого
атрибута – буквально атрибута. Нам необходимо пометить нашу миграцию атрибутом `[Migration]`, который нужен чтобы
библиотека смогла найти нашу миграцию в дальнейшем. Данный атрибут содержит данные о версии миграции, а также её
название.

```csharp
[Migration(version: 1727972936, description: "Initial migration")]
public class InitialMigration : IMigration
```

Давайте немного поговорим про конвенции определения миграций. Существуют различные способы версионирования миграций,
основными являются порядковые номера и временные отметки. Главное – чтобы миграции имели уникальные версии и отражали
какую-либо хронологичность. Подход с временными метками помогает избежать коллизий при командной разработке. Библиотека
накатывает те миграции, что её не были применены, не только те, чья версия больше версии последней применённой миграции.
Это позволяет двум разработчикам параллельно заводить независимые миграции и не получать коллизии по версиям без
необходимости синхронизироваться в распределении порядковых номеров. Также, существуют конвенции по неймигу файлов
миграций, они должны содержать версию миграции в качестве префикса. Это позволяет хронологически сортировать миграции в
вашей IDE. Такой подход подразумевает необходимость начинать название файла с цифры, что нельзя сделать с названием
типов в C#. Поэтому название файла с классом миграции не будет совпадать с названием самого класса миграции. В C#
существует диагностика обязующая соответствие этих двух имён, поэтому вам придётся заглушать её при определении
миграций.

```csharp
#pragma warning disable SA1649

[Migration(version: 1727972936, description: "Initial migration")]
public class InitialMigration : IMigration
```

### Хранение миграций

Так как всё же работает данная библиотека? Как она понимает что нужно выполнить, а что нет? Для этого библиотека создаёт
специальную таблицу в схеме, где накатываются миграции. Данная таблица называется `VersionInfo` и содержит версию,
название и время, когда миграция была применена.

```sql
create table "VersionInfo"
(
    "Version"     bigint not null,
    "AppliedOn"   timestamp,
    "Description" varchar(1024)
);
```

Когда вы запускаете применение миграции, библиотека определяет миграции, которые ещё не были накачены и выполняет их.
Таким образом одна миграция выполняется лишь единожды на базе данных.

### Выполнение миграций

Выполнение миграций состоит из двух этапов – регистрация необходимых типов в DI, и вызов самого мигратора.

Первым делом мы должны вызвать метод `AddFluentMigratorCore` для регистрации основных типов библиотеки. Далее мы
вызываем метод `CofigureRunner`, где задаём конфигурации нашего мигратора. Здесь мы вызываем метод `AddPostgres` для
того чтобы выбрать Postgres провайдер для выполнения миграций, он подключается через пакет
`FluentMigrator.Runner.Postgres`. Также необходимо передать строку для подлючения к базе. Финальным шагом конфигурации
должно быть задание источника самих миграций, делается это через метод `WithMigrationsIn`, куда мы передаём сборку в
которой лежат миграции. Здесь используется механизм assembly scanning для нахождения миграций.

```csharp
serviceCollection
    .AddFluentMigratorCore()
    .ConfigureRunner(runner => runner
        .AddPostgres()
        .WithGlobalConnectionString("Host=localhost;Username=postgres;Password=postgres")
        .WithMigrationsIn(typeof(IMigrationAssemblyMarker).Assembly));
```

После этого, когда вы соберёте `ServiceProvider` для вашего DI контейнера, вы можете создать скоуп и достать из него
объект `IMigrationRunner`, метод `MigrateUp` которого будет накатывать миграции.

```csharp
await using (AsyncServiceScope scope = serviceProvider.CreateAsyncScope())
{
    IMigrationRunner runner = scope.ServiceProvider.GetRequiredService<IMigrationRunner>();
    runner.MigrateUp();
}
```

Аналогично, вы можете вызвать метод `MigrateDown` чтобы откатиться то какой-то конкретной версии. В таком случае
библиотека отсортирует все миграции, следующие после выбранной версии, по убыванию номера их версии и выполнит их
скрипты для откатывания миграции.

```csharp
await using (AsyncServiceScope scope = serviceProvider.CreateAsyncScope())
{
    IMigrationRunner runner = scope.ServiceProvider.GetRequiredService<IMigrationRunner>();
    runner.MigrateDown(1727972936);
}
```