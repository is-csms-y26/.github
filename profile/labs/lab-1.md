# Лабораторная 1

## Задание 1

### Отрабатываемый материал

Основы .NET, генераторы, IEnumerable, IAsyncEnumerable, IEnumerator, IDisposable

### Задача

Реализовать метод расширения над `IEnumerable`, выполняющий операцию "склейки коллекций". Метод должен работать
аналогично методу `Zip` из LINQ, но, в отличие от него, метод, реализуемый вами должен принимать нефиксированное
количество "склеиваемых коллекций" (с использованием конструкции `params`).

Также необходимо реализовать такой же метод для `IAsyncEnumerable`. (В реализации данного метода разрешается
использование пакета `System.Linq.Async`).

### Функциональные требования

- Передача "других" коллекций для склейки через `params`
- Работа с коллекциями, имеющими одинаковый тип элемента

### Нефункциональные требования

- Коллекции, являющиеся входными параметрами должны иметь тип `IEnumerable<T>`/`IAsyncEnumerable<T>` (за исключением
  параметра с params)
- Реализация должна корректно утилизировать ресурсы
- Реализация должна обрабатывать ситуации когда переданы коллекции различной длины (выбор конкретной обработки –
  остаётся за вами)
- Тесты должны быть написаны на фреймворке XUnit с использованием библиотеки FluentAssertions

### Тестовые сценарии

#### Сценарий 1

**Arrange**

Методы Zip и ZipAsync вызываются на коллекции, не передавая ничего как аргумент.

**Assert**

Элементы результирующей коллекции должны быть коллекциями, содержащими единственный элемент из изначальной коллекции.

#### Сценарий 2

**Arrange**

Методы Zip и ZipAsync вызываются с различным количеством коллекций, длина которых равна длине коллекции, на которой
вызывается метод.

> Данный тест должен быть реализован как Theory, с использованием MemberData

#### Сценарий 3

**Arrange**

Методы Zip и ZipAsync вызываются с различным количеством коллекций, длина которых не равна длине коллекции, на которой
вызывается метод.

**Assert**

Результат операции должен соответствовать той обработке, что вы выбрали в реализации методов

> Данный тест должен быть реализован как Theory, с использованием MemberData

## Задание 2

### Отрабатываемый материал

async/await, TaskCompletionSource, CancellationToken

### Задача

Реализовать клиент-обёртку, поддерживающую async/await над сервисом, поддерживающим "реактивный" подход к реализации
асинхронного взаимодействия.

Предположим мы имеем какую-то стороннюю библиотеку, которую необходимо интегрировать в наш код. Библиотека выполняет
достаточно долгие операции, по этой причине имеет реактивный способ интеграции – мы можем инициировать какую-либо
операцию, а потом реализация библиотеки может отправить нам результат. Разработчики данной библиотеки не были знакомы с
концепциями async/await, поэтому предоставляют следующие интерфейсы:

```csharp
public sealed record RequestModel(string Method, byte[] Data);
```

```csharp
public sealed record ResponseModel(byte[] Data);
```

```csharp
public interface ILibraryOperationService
{
    void BeginOperation(Guid requestId, RequestModel model, CancellationToken cancellationToken);
}
```

```csharp
public interface ILibraryOperationHandler
{
    void HandleOperationResult(Guid requestId, byte[] data);

    void HandleOperationError(Guid requestId, Exception exception);
}
```

Интерфейс `ILibraryOperationService` реализован самой библиотекой, он используется, для того чтобы запустить в ней
какую-либо операцию. Интерфейс `ILibraryOperationHandler` же, должен быть реализован вами, его будет использовать
библиотека, для того чтобы реактивно отправлять результаты операций, которые могут быть как успешные, так и нет.

Такой механизм взаимодействия не особо удобен, концепция async/await позволяет писать код, выполняемый асинхронно в
синхронном стиле и сильно упрощает когнитивную сложность при чтении кода. Поэтому вам необходимо будет реализовать
интерфейс, позволяющий вызывать операции данной библиотеки в стиле async/await.

```csharp
public interface IRequestClient
{
    Task<ResponseModel> SendAsync(RequestModel request, CancellationToken cancellationToken);
}
```

Соответственно, вам необходимо написать класс, реализующий как интерфейс `IRequestClient`, так и интерфейс
`ILibraryOperationHandler`.

### Нефункциональные требования

- Реализация должна поддерживать многопоточное выполнение кода (несколько потоков могут как вызывать операцию, так и
  отдать её результат)
- Реализация должна быть устойчивой к различным race condition, например
    - Операция выполняется библиотекой быстро, ещё до окончания вызова метода `BeginOperation`
    - Операция отменяется быстро, ещё до вызова метода `BeginOperation`
- Реализация должна корректно поддерживать отмену. Подразумевается, что реализация библиотеки её поддерживает, и
  в случае когда операция отменяется не пришлёт результат операции. В таком случае вызов метода `SendAsync` не должен
  приводить к бесконечному ожиданию.
- Тесты должны быть написаны на фреймворке XUnit с использованием библиотеки FluentAssertions

### Тестовые сценарии

Для реализации тестов вам понадобится мок `ILibraryOperationService`, для этого необходимо воспользоваться библиотекой
NSubstibute.

#### Сценарий 1

Вызывается метод `SendAsync`, через какое-то время вызывается метод `HandleOperationResult`, при авейте таски,
полученной из `SendAsync` вы получаете переданный в хендлер результат.

#### Сценарий 2

Вызывается метод `SendAsync`, через какое-то время вызывается метод `HandleOperationError`, при авейте таски,
полученной из `SendAsync` должен быть выброшен экспешен, переданный в метод `HandleOperationError`.

#### Сценарий 3

Метод `SendAsync` вызывается с `CancellationToken`, который уже был отменён. При авейте таски, возвращённой методом,
должен быть выброшен `TaskCancelledException`.

#### Сценарий 4

Метод `SendAsync` вызывается с ещё не отменённым `CancellationToken`, через какое-то время токен должен быть отменён.
При авейте таски, возвращённой методом, должен быть выброшен `TaskCancelledException`.

#### Сценарий 5

Вызывается метод `SendAsync`, реализация `ILibraryOperationService`, переданная в класс, написанный вами, вызывает метод
`HandleOperationResult` прямо в методе `BeginOperation`. При авейте таски, полученной из `SendAsync` вы получаете
переданный в хендлер результат.

#### Сценарий 6

Вызывается метод `SendAsync`, реализация `ILibraryOperationService`, переданная в класс, написанный вами, вызывает метод
`HandleOperationError` прямо в методе `BeginOperation`. При авейте таски, полученной из `SendAsync` должен быть выброшен
экспешен, переданный в метод `HandleOperationError`.

#### Сценарий 7

Вызывается метод `SendAsync`, реализация `ILibraryOperationService`, переданная в класс, написанный вами, отмену
`CancellationToken` прямо в методе `BeginOperation`. При авейте таски, полученной из `SendAsync` должен быть выброшен
`TaskCancelledException`.

## Задание 3

### Отрабатываемый материал

Каналы, потоки, Parallel

### Задача

Реализовать систему обработки сообщений при помощи каналов. Предположим нем необходимо иметь возможность отсылать
какие-либо сообщения из нескольких потоков, но обрабатывать их в один поток несколькими обработчиками.

При наивной реализации (вызов обработчиков сообщений прямо при их отправке), каждому потоку, отправляющему сообщения,
будет необходимо ожидать выполнения обработки сообщений отправленных ранее, другими потоками. Такой подход имеет
несколько недостатков:

- Допустим потоки, отправляющие сообщения откуда-то их читают. В таком случае, если операция чтения сообщения
  выполняется значительно быстрее операции его обработки, мы будем значительно тормозить чтение
- Так как каждая обработка выполняется разрозненно, в отдельном потоке, что отправил сообщение, мы теряем возможность
  батчинга обработки, что также потенциально замедляет процесс, так как батчинг позволяет распределить накладные расходы
  при выполнении операций на несколько объектов.
- Мы имеем накладные расходы на синхронизацию потоков, что также тормозит чтение данных.

Поэтому нам необходимо разделить ответственность за запись сообщений и их обработку между разными потоками. И сделать
это мы можем при помощи каналов!

В рамках данного задания наша объектная модель будет состоять из нескольких типов:

```csharp
public record Message(string Title, string Text);
```

```csharp
public interface IMessageSender
{
    ValueTask SendAsync(Message message, CancellationToken cancellationToken);
}
```

```csharp
public interface IMessageProcessor
{
    Task ProcessAsync(CancellationToken cancellationToken);

    void Complete();
}
```

```csharp
public interface IMessageHandler
{
    ValueTask HandleAsync(IEnumerable<Message> messages, CancellationToken cancellationToken);
}
```

- `IMessageSender` – используется потоками, записывающими сообщения
- `IMessageProcessor` – используется потоком, обслуживающим очередь сообщений, а также потоком, управляющим циклом жизни
  вашей программы, останавливающим обработку
- `IMessageHandler` – реализует батчёвую обработку полученных сообщений.

`IMessageSender` будет реализован классом `MessageProcessor`, кроме метода отправки (записывающего сообщение в канал) он
должен
содержать метод `ProcessAsync`, который запускает чтение данных из канала и вызывает `IMessageHandler` для обработки
сообщений.

> Так как пакет `System.Linq.Async` не содержит метода аналогичного `Chunk` из обычного LINQ, вам необходимо будет
> воспользоваться методом расширения `ChunkAsync` из пакета `Itmo.Dev.Platform.Common`.

`IMessageHandler` реализует запись батча сообщений в консоль. В рамках данной лабораторной подразумевается, что
системные вызовы (представленные методом `Conole.WriteLine`) – дорогая операция, поэтому их необходимо минимизировать.
В реализации данного хендлера вы должны будете сначала собрать строку из всех сообщений и только потом писать её в
консоль.

### Нефункциональные требования

- Для реализации очереди обработки сообщений должны быть использованы каналы
- Реализация должна содержать батчинг сообщений
- Все значения, используемые в реализации (конфигурация канала, размер батчей, время таймаута батчинга, ...) должны быть
  параметризуемы
- В рамках метода `HandleAsync` вызов `Console.WriteLine` должен происходить единожды
- При попытке записи в заполненный канал, наиболее старые сообщения должны быть удалены из канала

### Тестовый сценарий

В рамках данной лабораторной вы должны будете подготовить тестовый сценарий в виде запускаемого консольного скрипта (
Program.cs).

В данном скрипте вам нужно будет:

- Создать объект `MessageProcessor`, передав в него консольный хендлер и распределить его на объекты двух разных типов

```csharp
var implementation = new MessageProcessor([new ConsoleMessageHandler()]);

IMessageProcessor processor = implementation;
IMessageSender sender = implementation;
```

- Запустить таску в "фоновом режиме" вызывав метод `ProcessAsync` у `IMessageProcessor`
- Используя метод `Parallel.ForEachAsync` создать некоторое количество сообщений и отправить их в `IMessageSender`
- После выполнения метода `Parallel.ForEachAsync` необходимо вызвать метод `Complete` в `IMessageProcessor`
- Далее необходимо заавейтить таску, которая была возвращена при вызове `ProcessAsync`

В итоге ваша программа должна вывести в консоль все сообщения и завершиться.